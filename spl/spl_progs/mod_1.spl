//------------------------------PROCESS MANAGER MODULE-----------------------------
//-----------------------------MODULE 1----------------------------------------------

alias functionNum R1;
alias exitPID R2;

if (functionNum == GET_PCB_ENTRY) then

	alias i R4;
	i = 0;
	
	//loop through the Process Table
	//if process table entry free
	//return index
	while (i < 16) do

		if ([PROCESS_TABLE + i * 16 + 4] == TERMINATED) then
		
			alias procs_table R5;
			procs_table = PROCESS_TABLE + i*16;
			[procs_table + 1] = i;
			[procs_table + 4] = ALLOCATED;
			[procs_table + 14] = PAGE_TABLE_BASE + 20 * i;
			[procs_table + 15] = 10;
			R0 = i;
			return;		
	
		endif;
		i = i + 1;

	endwhile;

	//if none of the process table is free
	R0 = -1;
	return;

endif;

if (functionNum == FREE_USER_AREA_PAGE) then

	alias UAPN R3;
	UAPN = [PROCESS_TABLE + exitPID * 16 + 11];
	backup;
	R1 = RELEASE_PAGE;
	R2 = UAPN;
	call MOD_2;
	restore;	
	return;

endif;

if (functionNum == EXIT_PROCESS) then 

	backup;
	R1 = FREE_PAGE_TABLE;
	R2 = exitPID;
	call MOD_1;
	restore;

	backup;
	R1 = FREE_USER_AREA_PAGE;
	R2 = exitPID;
	call MOD_1;
	restore;

	[PROCESS_TABLE + exitPID * 16 + 4] = TERMINATED;

	return;

endif;

if  (functionNum == FREE_PAGE_TABLE) then

	alias page_table_base R1;
	R1 = PAGE_TABLE_BASE + exitPID * 20;
	//invalidate the page table entries for the library
	[page_table_base + 0] = -1;
	[page_table_base + 1] = "0000";
	[page_table_base + 2] = -1;
	[page_table_base + 3] = "0000";

	//release the page for each valid page table entry in the page table, and invalidate the entry
	alias i R4;
	i = 4;
	while (i <= 18) do

		if ([page_table_base + i] != -1) then
		
			backup;
			R1 = RELEASE_PAGE;
			R2 = [page_table_base + i];
			call MOD_2;
			restore;
			[page_table_base + i] = -1;
			[page_table_base + i + 1] = "0000";

		endif;
		i = i + 2;	

	endwhile;

	//Release the disk block, and invalidate the DISK_MAP_TABLE
	//call RELEASE BLOCK to free the occupied block
	i = 0;
	while (i < 10) do

		if (([DISK_MAP_TABLE + exitPID*10 + i] != -1) && (i == 2 || i == 3 || i == 8 || i == 9)) then 

			backup;
			R1 = RELEASE_BLOCK;
			R3 = exitPID;
			R2 = [DISK_MAP_TABLE + exitPID*10 + i];
			call MOD_2;
			restore;

		endif;
		[DISK_MAP_TABLE + exitPID*10 + i] = -1;
		i = i + 1;

	endwhile;

	return;

endif;
